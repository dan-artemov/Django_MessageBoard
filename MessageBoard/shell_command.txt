
# Импорт необходимых модулей
from news.models import *
from django.db.models import Sum
from datetime import datetime


# 1. Создадим трех произвольных пользователей
us1 = User.objects.create_user('Bloger')
us2 = User.objects.create_user('RandomUser')
us3 = User.objects.create_user('NotAuthor')

# 2. Создадим два объекта модели Author, связанные с пользователями
au1 = Author.objects.create(users=us1)
au2 = Author.objects.create(users=us2)

# 3. Добавим 4 категории в модель Category
sport = Category.objects.create(category='Спорт')
politics = Category.objects.create(category='Политика')
economy = Category.objects.create(category='Экономика')
culture = Category.objects.create(category='Культура')

# 4. Добавим 2 статьи и 1 новость.

P1=Post.objects.create(author=au1, post_type=Post.article, post_header='Полный список вопросов с собеседований по Python для дата-сайентистов и инженеров', post_text='Бывает, что компания ищет дата-сайентиста, а на самом деле ей нужен Python-разработчик. Поэтому при подготовке к собеседованию есть смысл освежить в памяти информацию по Python, а не только штудировать алгоритмы. Перевели статью разработчика, который не раз попадал в такую ситуацию и на основе своего опыта составил список из 53 вопросов и ответов для подготовки к собеседованию. Большинство исследователей данных пишут много кода, поэтому такой список пригодится и дата-сайентистам, и инженерам. Он будет полезен и для соискателей, и для тех, кто проводит собеседования, и для тех, кто просто изучает Python. Вопросы идут в случайном порядке. Поехали. 1. В чем разница между списком и кортежем? Мне задавали этот вопрос буквально на каждом собеседовании по Python/data science. Выучите ответ как свои пять пальцев: Список можно изменить после создания. Кортеж нельзя изменить после создания. Список упорядочен. Он представляет собой упорядоченные последовательности объектов, как правило, одного и того же типа. Например, все имена пользователей упорядочены по дате создания. У кортежа есть структура. В каждом индексе могут сосуществовать различные типы данных.')

P2=Post.objects.create(author=au1, post_type=Post.article, post_header='10 полезных сочетаний клавиш в PyCharm', post_text='Сегодня я хочу поделиться с вами своими лайфхаками касательно работы в PyCharm, ведь мы все хотим сократить время разрабатывая проект, а в этом нам помогут быстрые команды при помощи сочетаний клавиш. Так как я предпочитаю пользоваться операционной системой семейства Windows, сочетания клавиш будут заточены под нее. Перед тем как применять данные комбинации, проследите за тем чтобы у вас стояла английская раскладка, иначе, команды будут совсем другие. Быстрое изменение регистра. Иногда полезно быстро изменить регистр слов с верхнего на нижний, или наоборот, в этом нам поможет сочетание клавиш Ctrl + Shift + U. Быстрое форматирование кода по стандарту PEP 8. Скопированный код с сайта чаще всего требует форматирования, особенно это касается отступов, вручную это делать долго и нудно, поэтому существует команда Ctrl + Alt + L, она в миг исправит все ошибки форматирования в коде и расставит все по своим местам. Закомментировать код.Очень полезное и всеми любимое сочетание клавиш быстрого закомментирования текста, выручает, когда закомментировать часть кода чтобы избежать его выполнения Ctrl + /')

N1 = Post.objects.create(author=au2, post_type=Post.news, post_header='All-Python Humble Bundle out now from No Starch Press!', post_text='Вы думали о том, чтобы углубиться в новую тему в Python, или, может быть, только начинаете? У вас есть шанс получить целую серию отличных книг по Python по выгодной цене и помочь PSF, пока вы этим занимаетесь! No Starch Press, независимое издательство технических книг и партнер-спонсор PSF, только что объявило о партнерстве с Humble Bundle, которое позволяет вам платить столько, сколько вы хотите, за все названия электронных книг без DRM на Python для начинающих и профессионалов. И часть выручки от этого пакета поступает в PSF! Пакет Python, без крахмального пресса действует до 22 мая. В комплект входит тщательно подобранная подборка названий для всех уровней, таких как ускоренный курс Python (Эрик Маттес), Автоматизируйте скучные вещи с помощью Python (Эл Свейгарт), Заставьте Python говорить (Марк Лю) и Учитесь кодировать, решая проблемы (Дэниел Зингаро). ')

# 5. Присвоим созданным статьям категории (как минимум в одной статье/новости должно быть не меньше 2 категорий). 
# Присвоим статье Р1 две категории: Политика и Экономика
P1.categories.add(economy)
P1.categories.add(politics)

# Присвоим статье Р2 категорию: Спорт
P2.categories.add(sport)

# Присвоим новости N1 две категории: Культура и Экономика
N1.categories.add(economy)
N1.categories.add(culture)

# 6. Создадим как минимум 4 комментария к разным объектам модели Post (в каждом объекте должен быть как минимум один комментарий).
C1_2 = Comment.objects.create(post=P1, user=us2, comment='Бестолковая статья, моя лучше')
C1_3 = Comment.objects.create(post=P1, user=us3, comment='Отличная статья')
C2_2 = Comment.objects.create(post=P2, user=us2, comment='Это статья норм')
C2_3 = Comment.objects.create(post=P2, user=us3, comment='Отличная статья')
C3_1 = Comment.objects.create(post=N1, user=us1, comment='Твоя новость устарела, мои статьи лучше')
C3_3 = Comment.objects.create(post=N1, user=us3, comment='Отличная Новость')

# 7. Применим функции like() и dislike() к статьям/новостям и комментариям, скорректируем рейтинги этих объектов		
# Сначала отлайкаем комменты
C1_2.dislike()
C1_3.like()
C2_2.like()
C2_3.like()
C3_1.dislike()
C3_3.like()
C3_1.dislike()
# Затем отлайкаем посты
P1.like()
P2.like()
P2.like()
N1.dislike()

# 8. Обновим рейтинг Автора в соответствии с заданными условиями расчета
au1.update_rating()
au2.update_rating()
# (Математику расчета Рейтинга в модели Author проверил. Все сходится.)

# 9. Выведем username и рейтинг лучшего пользователя (применяя сортировку и возвращая поля первого объекта).

best_author = Author.objects.order_by("-user_rating").first()
print(f'Лучший автор: {best_author.users.username}\nРейтинг пользователя: {best_author.user_rating}')

# 10. Выведем дату добавления, username автора, рейтинг, заголовок и превью лучшей статьи, 
# основываясь на лайках/дислайках к этой статье.
best_post= Post.objects.order_by("-post_rating").first()
print(f'Дата добавления: {best_post.data_create.strftime("%y-%m-%d")}\n'
	  f'Автор: {best_post.author.users.username}\n'
		f'Рейтинг статьи: {best_post.post_rating}\n'
		f'------Заголовок------------------\n'
		f'{best_post.post_header}\n'
		f'------Превью статьи--------------\n' 
		f'{best_post.preview()}')
		
# 11. Выведем все комментарии (дата, пользователь, рейтинг, текст) к этой статье.
all_comments = best_post.comment_set.all().values("data_create","user__username","comment_rating","comment")
for i in all_comments:
	print(f'-------------------------------------------\n'
			f'Дата комментария: {i["data_create"].strftime("%y-%m-%d %H:%M")}\n'
			f'Пользователь: {i["user__username"]}\n'
			f'Рейтинг комментария: {i["comment_rating"]}\n'
			f'Комментарий: {i["comment"]}')

# Конец!
	

